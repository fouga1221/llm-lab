"""
Building actions from LLM output and performing self-checks.
Corresponds to section 7.3 of the detailed design document.
"""
import json
from typing import Dict, Any, cast

from app.core.types import StructuredActions, empty_actions
from app.tooling.registry import FunctionRegistry

class ActionBuilder:
    """
    Extracts structured actions from the raw text output of an LLM.
    """
    def __init__(self, registry: FunctionRegistry) -> None:
        """
        Initializes the builder.

        Args:
            registry: The function registry to check against.
        """
        self.registry = registry

    def extract(self, text: str) -> StructuredActions:
        """
        Extracts a JSON block from the text and parses it into StructuredActions.
        This is a simplified implementation. A more robust version would handle
        cases where the JSON is embedded within other text or markdown.

        Args:
            text: The raw output from the LLM.

        Returns:
            A StructuredActions object. Returns an empty list if no valid actions are found.
        """
        try:
            # Find the JSON part of the text
            start_brace = text.find('{')
            end_brace = text.rfind('}')
            if start_brace != -1 and end_brace > start_brace:
                json_str = text[start_brace : end_brace + 1]
                data = json.loads(json_str)
                # Basic validation to ensure it looks like our target structure
                if 'actions' in data and isinstance(data['actions'], list):
                    return cast(StructuredActions, data)
        except (json.JSONDecodeError, TypeError):
            # If parsing fails, return an empty structure
            pass
        return empty_actions()

class SelfChecker:
    """
    Performs self-checks on the LLM's output to identify potential issues
    like hallucinated function calls or inconsistencies.
    """
    def __init__(self, registry: FunctionRegistry) -> None:
        """
        Initializes the checker.

        Args:
            registry: The function registry to validate against.
        """
        self.registry = registry

    def check(self, reply: str, actions: StructuredActions, registry: FunctionRegistry) -> Dict[str, Any]:
        """
        Analyzes the reply and actions to generate signals for the ConfidenceRouter.

        Args:
            reply: The natural language reply from the LLM.
            actions: The structured actions generated by the LLM.
            registry: The function registry.

        Returns:
            A dictionary of signals (e.g., hallucinated_functions, self_correction_attempts).
        """
        signals: Dict[str, Any] = {
            'hallucinated_functions': [],
            'self_correction_attempts': 0,
            'inconsistencies': []
        }

        # Check for hallucinated function names
        for action in actions.get('actions', []):
            func_name = action.get('function')
            if func_name and not registry.get(func_name):
                signals['hallucinated_functions'].append(func_name)

        # Check for self-correction markers in the reply text
        if "upon reflection" in reply.lower() or "on second thought" in reply.lower():
            signals['self_correction_attempts'] += 1
            
        # Check for inconsistencies (e.g., text says one thing, action does another)
        # This is a very complex task. Placeholder logic:
        if "I will follow you" in reply and not any(a.get('function') == 'npc_follow_player' for a in actions.get('actions', [])):
            signals['inconsistencies'].append("Reply mentions following, but action is missing.")

        return signals
